const orderRepository = require('../repositories/order.repository');
const Order = require('../models/order.model');

class OrderService {
  async createOrder(readerId, instanceId, rentDate, returnDeadline) {
    // Create a new order with PENDING_APPROVAL status
    const order = new Order(
      null, // rentId will be generated by DB
      readerId,
      instanceId,
      rentDate,
      returnDeadline,
      null, // returnDate is null initially
      'PENDING_APPROVAL', // Initial status
      null, // returnNotes is null initially
      null  // librarianId is null initially
    );
    
    const rentId = await orderRepository.create(order);
    return this.getOrderById(rentId);
  }
  
  async getOrderById(rentId) {
    return orderRepository.getById(rentId);
  }
  
  async getReaderOrders(readerId) {
    // Get all orders for a reader grouped by status
    const orders = await orderRepository.getOrdersByReaderId(readerId);
    
    // Group orders by status for frontend display
    return {
      active: orders.filter(order => order.status === 'ACTIVE'),
      pending_approval: orders.filter(order => order.status === 'PENDING_APPROVAL'),
      pending_return: orders.filter(order => order.status === 'PENDING_RETURN'),
      denied: orders.filter(order => ['DENIED', 'WAITING'].includes(order.status)),
      returned: orders.filter(order => order.status === 'RETURNED'),
    };
  }
  
  async approveOrder(rentId, librarianId) {
    const order = await this.getOrderById(rentId);
    if (!order) {
      throw new Error('Order not found');
    }
    
    if (order.status !== 'PENDING_APPROVAL') {
      throw new Error('Order cannot be approved in its current state');
    }
    
    // Update the book availability (decrease available copies)
    await orderRepository.updateBookAvailability(order.instanceId, -1);
    
    // Update order status to ACTIVE
    return orderRepository.updateStatus(rentId, 'ACTIVE', librarianId);
  }
  
  async denyOrder(rentId, librarianId, reason = '') {
    const order = await this.getOrderById(rentId);
    if (!order) {
      throw new Error('Order not found');
    }
    
    if (order.status !== 'PENDING_APPROVAL' && order.status !== 'PENDING_RETURN') {
      throw new Error('Order cannot be denied in its current state');
    }
    
    // Always set to DENIED whether it's a rental or return request
    return orderRepository.updateStatus(rentId, 'DENIED', librarianId, reason);
  }
  
  async initiateReturn(rentId) {
    const order = await this.getOrderById(rentId);
    if (!order) {
      throw new Error('Order not found');
    }
    
    // Allow both ACTIVE and DENIED status to initiate returns
    if (order.status !== 'ACTIVE' && order.status !== 'DENIED') {
      throw new Error('Order must be active or denied to initiate return');
    }
    
    // Update order status to PENDING_RETURN
    return orderRepository.updateStatus(rentId, 'PENDING_RETURN');
  }
  
  async approveReturn(rentId, librarianId, returnNotes = '') {
    const order = await this.getOrderById(rentId);
    if (!order) {
      throw new Error('Order not found');
    }
    
    if (order.status !== 'PENDING_RETURN') {
      throw new Error('Order must be in pending return state');
    }
    
    // Get current date for returnDate
    const returnDate = new Date().toISOString().split('T')[0];
    
    // Update the book availability (increase available copies)
    await orderRepository.updateBookAvailability(order.instanceId, 1);
    
    // Update order status to RETURNED with return date
    return orderRepository.updateStatus(rentId, 'RETURNED', librarianId, returnNotes, returnDate);
  }
  
  async deleteOrder(rentId, userId = null) {
    const order = await this.getOrderById(rentId);
    if (!order) {
      throw new Error('Order not found');
    }
    
    // Allow deletion in these cases:
    // 1. The order is denied (by a librarian)
    // 2. The order is pending approval AND the request comes from the order's reader
    if (order.status === 'DENIED' || 
        (order.status === 'PENDING_APPROVAL' && userId && order.readerId === userId)) {
      return orderRepository.delete(rentId);
    }
    
    throw new Error('This order cannot be cancelled in its current state');
  }
  
  async getLibrarianOrders(terminalId, status = null) {
    return orderRepository.getOrdersForLibrarian(terminalId, status);
  }
  
  async getPendingApprovalOrders(terminalId) {
    return orderRepository.getOrdersForLibrarian(terminalId, 'PENDING_APPROVAL');
  }
  
  async getPendingReturnOrders(terminalId) {
    return orderRepository.getOrdersForLibrarian(terminalId, 'PENDING_RETURN');
  }
  
  async getAllOrders() {
    return orderRepository.getAll();
  }
  
  // Add this method to the OrderService class if it doesn't exist
  async getBookForInstance(instanceId) {
    try {
      // First get the instance to get the bookId
      const query = `
        SELECT bi.bookId FROM BookInstance bi 
        WHERE bi.instanceId = ?
      `;
      
      return new Promise((resolve, reject) => {
        pool.query(query, [instanceId], (err, results) => {
          if (err) return reject(err);
          if (!results || results.length === 0) return resolve(null);
          
          const bookId = results[0].bookId;
          
          // Now get the book details
          const bookQuery = `
            SELECT * FROM Book WHERE bookId = ?
          `;
          
          pool.query(bookQuery, [bookId], (err, bookResults) => {
            if (err) return reject(err);
            if (!bookResults || bookResults.length === 0) return resolve(null);
            
            resolve(bookResults[0]);
          });
        });
      });
    } catch (error) {
      console.error('Error getting book for instance:', error);
      return null;
    }
  }
}

module.exports = new OrderService();